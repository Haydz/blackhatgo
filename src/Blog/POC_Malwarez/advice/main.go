package main

import (
	"bufio"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"time"
)

type Msg struct {
	ChildID int
	Message string
}

// AdminServer listens on a TCP socket and prints each line sent to STDOUT
type AdminServer struct {
	Port    int
	started chan bool
}

// MustStart listens on Port and blocks until it's ready to accept connections.
// Prefixing a method name with Must indicates that it panics if it's unsuccessful
// which is fine in this case since there's not much we can do if the server can't start
func (s *AdminServer) MustStart() {
	s.started = make(chan bool)
	go s.startServer()
	// block until server is listening
	<-s.started
}

func (s *AdminServer) startServer() {
	listener, e := net.Listen("tcp", fmt.Sprintf("127.0.0.1:%d", s.Port))
	if e != nil {
		log.Fatal("cant listen")
	}
	s.started <- true

	for {
		conn, e := listener.Accept()
		if e != nil {
			log.Fatal("cant accept")
		}

		go s.handleConn(conn)
	}
}

func (s *AdminServer) handleConn(conn net.Conn) {
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		decodedBs, e := base64.StdEncoding.DecodeString(line)
		if e != nil {
			log.Println(e.Error())
			continue
		}

		msg := Msg{}
		e = json.Unmarshal(decodedBs, &msg)
		if e != nil {
			log.Println(e.Error())
			continue
		}

		fmt.Printf("Msg from %d: %s\n", msg.ChildID, msg.Message)
	}
}

// ParentServer establishes a TCP connection to the admin server
// and listens on a TCP socket of it's own, proxying the connection
// between the two
type ParentServer struct {
	Port      int
	AdminAddr string
	toAdmin   chan string
	started   chan bool
}

// MustStart listens on Port and blocks until it's ready to accept connections.
// Prefixing a method name with Must indicates that it panics if it's unsuccessful
// which is fine in this case since there's not much we can do if the server can't start
func (s *ParentServer) MustStart() {
	e := s.connectToAdmin()
	if e != nil {
		log.Fatal(e.Error())
	}

	s.started = make(chan bool)
	go s.startServer()
	<-s.started
}

func (s *ParentServer) startServer() {
	listener, e := net.Listen("tcp", fmt.Sprintf("127.0.0.1:%d", s.Port))
	if e != nil {
		log.Fatal(e.Error())
	}
	s.started <- true

	for {
		conn, e := listener.Accept()
		if e != nil {
			log.Println(e.Error())
			continue
		}

		go s.handleConn(conn)
	}
}

func (s *ParentServer) handleConn(conn net.Conn) {
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		s.toAdmin <- scanner.Text()
	}
}

func (s *ParentServer) connectToAdmin() error {
	// using a buffered channel to allow for some backpressure to build up in mem
	s.toAdmin = make(chan string, 1000)

	conn, e := net.Dial("tcp", s.AdminAddr)
	if e != nil {
		return e
	}

	go func() {
		for msg := range s.toAdmin {
			_, e := fmt.Fprintln(conn, msg)
			if e != nil {
				log.Println(e.Error())
			}
		}
	}()

	return nil
}

type ChildProcess struct {
	ID         int
	ParentAddr string
}

func (c *ChildProcess) MustStart() {
	conn, e := net.Dial("tcp", c.ParentAddr)
	if e != nil {
		log.Fatal(e.Error())
	}

	go func() {
		for range time.Tick(3 * time.Second) {
			msg := Msg{
				ChildID: c.ID,
				Message: "hacking in progress...",
			}

			jsonEncodedBs, e := json.Marshal(&msg)
			if e != nil {
				log.Println(e.Error())
				continue
			}

			encodedMsg := base64.StdEncoding.EncodeToString(jsonEncodedBs)
			_, e = fmt.Fprintln(conn, encodedMsg)
			if e != nil {
				log.Println(e.Error())
			}
		}
	}()
}

func main() {
	numChildren := 5
	adminPort := 1337
	parentPort := 1338
	adminAddr := fmt.Sprintf("localhost:%d", adminPort)

	admin := AdminServer{Port: adminPort}
	admin.MustStart()

	parent := ParentServer{
		Port:      parentPort,
		AdminAddr: adminAddr,
	}
	parent.MustStart()

	for i := 0; i < numChildren; i++ {
		child := ChildProcess{
			ID:         i + 1,
			ParentAddr: fmt.Sprintf("localhost:%d", parentPort),
		}

		child.MustStart()
	}

	// block for 30s
	<-time.After(30 * time.Minute)
}
