package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"os"
	"strings"
)

// JSON format for ID and command
type Results struct {
	ID int
	//Command string
	Output string
}

func main() {

	//UNCOMMENT FOR MANUAL PORT NUMBER ASSIGNMENT
	/* arguments := os.Args
	// if len(arguments) == 1 {
	// 	fmt.Println("Please provide port number")
	// 	return
	 }
	*/

	for {
		//setting up connection for port 9999
		PORT := ":" + "9999"
		//listening for connectiong
		l, err := net.Listen("tcp", PORT)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer l.Close()
		//accepting a connection now known as c
		c, err := l.Accept()
		if err != nil {
			fmt.Println(err)
			return
		}
		//Once connected, commands can be sent
		//read in command to be executed by child
		reader := bufio.NewReader(os.Stdin)
		fmt.Print(">> ")
		text, _ := reader.ReadString('\n')
		fmt.Fprintf(c, text+"\n")

		// Close if STOP is typed
		if strings.TrimSpace(string(text)) == "STOP" {
			fmt.Println("Closing TCP server!")
			return
		}

		//DECODING JSON
		// using Results structure format
		var outputTest Results
		//connecting decoder to read in data from c (connection)
		decoder := json.NewDecoder(c)
		//decoding data from c into Results structure format
		decoder.Decode(&outputTest)
		//Printing ID of child and command
		fmt.Println(outputTest.ID, " : ", outputTest.Output)
		//Closing connecting and listening ports.
		/* this is becuase it will hang, decoding and encoding seem to
		close connection after sending */
		l.Close()
		c.Close()

	}

}
